# SOLID 原则

## 单一职责原则(Single Responsibility Principle)

尽量让每个类只负责软件中的一个功能， 并将该功能完全**封装**（你也可称之为隐藏） 在该类中。

这条原则的主要目的是减少复杂度。 你不需要费尽心机地去构思如何仅用200行代码来实现复杂设计， 实际上完全可以使用十几个清晰的方法。

**总结**:

- 单一职责原则要求每个类专注于完成一项职责。
- 它强调代码的简洁性和清晰性，减少类的复杂度，增强代码的可维护性。
- 应用单一职责原则时，需要结合实际需求，找到合理的职责划分边界，避免过度设计。

> 核心: 一个类应该仅有一个引起变化的原因，即修改一个类的原因只能有一个。

## 开闭原则(Open/Close Principle)

本原则的主要理念是在实现新功能时能保持已有代码不变。

如果你可以对一个类进行扩展， 可以创建它的子类并对其做任何事情（如新增方法或成员变量、 重写基类行为等）， 那么它就是**开放**的。
有些编程语言允许你通过特殊关键字（例如`final`） 来限制对于类的进一步扩展， 这样类就不再是“开放” 的了。
如果某个类已做好了充分的准备并可供其他类使用的话（即其接口已明确定义且以后不会修改）， 那么该类就是**封闭**（你可以称之为**完整**） 的。

**总结**:

- 开闭原则的核心在于通过抽象和多态，使得系统在需求变化时易于扩展而无需修改现有代码。
- 它有助于提高系统的稳定性、灵活性和可维护性，是面向对象设计的一个重要原则。
- 在实际应用中，应结合具体场景，合理设计系统的扩展点，避免过度设计。

> 核心: 对于扩展，类应该是 "开放" 的；对于修改，类则应该是 "封闭" 的。

## 里氏替换原则(Liskov Substitution Principle)

这意味着子类必须保持与父类行为的兼容。 在重写一个方法时， 你要对基类行为进行扩展， 而不是将其完全替换。

**总结**:

- 里氏替换原则的核心是保证子类能够完全替代父类使用，而不会破坏程序的正确性。
- 违反的常见原因：
  - 子类重写父类方法时改变了行为预期。
  - 子类在扩展功能时未遵守父类的语义。
- 如何遵守：
  - 明确父类的行为契约，子类必须严格遵守。
  - 在设计时优先考虑组合，而非继承，减少不必要的继承关系。
  - 使用抽象类和接口来保证行为的一致性。

> 核心: 子类对象必须能够替换掉父类对象，并且程序的行为保持正确。

## 接口隔离原则(Interface Segregation Principle)

尽量缩小接口的范围， 使得客户端的类不必实现其不需要的行为。

根据接口隔离原则， 你必须将“臃肿” 的方法拆分为多个颗粒度更小的具体方法。 客户端必须仅实现其实际需要的方法。
否则， 对于“臃肿” 接口的修改可能会导致程序出错， 即使客户端根本没有使用修改后的方法。

**总结**:

- **定义**：接口隔离原则要求我们为不同的客户端设计独立的小接口，而不是一个通用的大接口。
- **优点**：
  - 减少依赖关系，降低耦合。
  - 避免类实现无关的接口方法。
  - 提高代码的可维护性和灵活性。
- **实现**：
  - 将大的接口拆分为多个小接口。
  - 针对具体需求实现所需的接口。
  - 避免使用 "万能接口"。

> 核心: 客户端不应该被迫依赖它们不需要的接口。

## 依赖倒置原则(Dependency Inversion Principle)

通常在设计软件时， 你可以辨别出不同层次的类。

**低层次的类**实现基础操作（例如磁盘操作、 传输网络数据和连接数据库等）
**高层次类**包含复杂业务逻辑以指导低层次类执行特定操作。

有时人们会先设计低层次的类， 然后才会开发高层次的类。当你在新系统上开发原型产品时， 这种情况很常见。
由于低层次的东西还没有实现或不确定， 你甚至无法确定高层次类能实现哪些功能。 如果采用这种方式， 业务逻辑类可能会更依赖于低层原语类。

依赖倒置原则建议改变这种依赖方式。

**总结**:

- **核心理念**：高层模块和低层模块都应该依赖于抽象，避免直接依赖具体实现。
- **优点**：
  - 降低模块之间的耦合度。
  - 提高代码的灵活性和可扩展性。
  - 便于单元测试。
- **实现方法**：
  - 面向接口编程。
  - 通过依赖注入或工厂模式提供具体实现。
- **适用场景**：
  - 复杂的系统中，高层逻辑和底层实现需要频繁变更。
  - 需要支持多种具体实现时。

> 核心: 高层次的类不应该依赖于低层次的类。两者都应该依赖于抽象接口。抽象接口不应依赖于具体实现。具体实现应该依赖于抽象接口。
