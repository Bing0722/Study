# 工厂方法(Factory Method)

**工厂方法**是一种创建型设计模式，其在父类中提供一个创建对象的方法，允许子类决定实例化对象的类型。

## 结构

- **产品**(Product)将会对接口进行声明。 对于所有由创建者及其子类构建的对象， 这些接口都是通用的。
- **具体产品**(Concrete Products)是产品接口的不同实现。
- **创建者**(Creator)类声明返回产品对象的工厂方法。 该方法的返回对象类型必须与产品接口相匹配。
- **具体创建者**(Concrete Creators)将会重写基础工厂方法，使其返回不同类型的产品。

## 适用场景

- 创建对象时不想暴露具体类的实例化过程
  - 当你希望客户端代码不需要知道具体的产品类是什么，只需知道产品接口即可。
  - 通过工厂方法，你可以将对象的创建交给子类来处理，从而实现与具体产品的解耦。

- 类的实例化需要满足某些条件或逻辑
  - 当对象的创建过程涉及到复杂的逻辑，工厂方法可以把这些逻辑封装在具体的工厂中。客户端只需要调用工厂方法，而不需要关心具体的创建过程。

- 提供可扩展的产品系列
  - 如果你有多个相关的产品类（例如不同类型的UI控件、数据库连接等），可以通过创建一个工厂方法来扩展这些产品类的生成，而不修改现有代码。

- 需要使用多态性创建不同类型的对象
  - 工厂方法让你通过父类的接口创建具体子类的实例。这样，你可以让子类决定具体创建哪种类型的产品。

## 实现方法

1. 让所有产品都遵循同一接口。 该接口必须声明对所有产品都有意义的方法。
2. 在创建类中添加一个空的工厂方法。 该方法的返回类型必须遵循通用的产品接口。
3. 在创建者代码中找到对于产品构造函数的所有引用。将它们依次替换为对于工厂方法的调用， 同时将创建产品的代码移入工厂方法。你可能需要在工厂方法中添加临时参数来控制返回的产品类型。

## 优缺点

**优点**：

- 你可以避免创建者和具体产品之间的紧密耦合。
- 单一职责原则。 你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
- 开闭原则。 无需更改现有客户端代码， 你就可以在程序中引入新的产品类型。

**缺点**：

- 应用工厂方法模式需要引入许多新的子类， 代码可能会因此变得更复杂。 最好的情况是将该模式引入创建者类的现有层次结构中。

## 总结

工厂方法模式通常用于以下目的：

- **解耦对象创建**：客户端不需要了解具体的产品类，降低了依赖关系。
- **增强扩展性**：通过增加新的具体工厂，系统可以轻松扩展支持新的产品类型。
- **简化复杂创建逻辑**：将复杂的对象创建逻辑封装到工厂类中，避免了客户端代码的复杂性。
- **提供一致性**：不同类型的产品通过工厂方法提供统一的接口。

> 核心思想：将创建对象的过程抽象出去，并且通过工厂方法来实现这个过程
