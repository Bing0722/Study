# 适配器(Adapter)

**适配器**是一种结构型设计模式，它能使接口不兼容的对象能够相互合作。

## 结构

- **客户端**（Client）是包含当前程序业务逻辑的类。
- **客户端接口**（ClientInterface） 描述了其他类与客户端代码合作时必须遵循的协议。
- **服务**（Service）中有一些功能类(通常来自第三方或遗留系统)。客户端与其接口不兼容，因此无法直接调用其功能。
- **适配器**（Adapter） 是一个可以同时与客户端和服务交互的类： 它在实现客户端接口的同时封装了服务对象。 适配器接受客户端通过适配器接口发起的调用， 并将其转换为适用于被封装服务对象的调用。

## 适用场景

- 当你希望使用某个类，但是其接口与其他代码不兼容时，可以使用适配器类。
- 如果您需要复用这样一些类，他们处于同一个继承体系，并且他们又有了额外的一些共同的方法， 但是这些共同的方法不是所有在这一继承体系中的子类所具有的共性。

## 实现方法

- 确保至少有两个类的接口不兼容：
  - 一个无法修改 （通常是第三方、 遗留系统或者存在众多已有依赖的类） 的功能性服务类。
  - 一个或多个将受益于使用服务类的客户端类。
- 声明客户端接口， 描述客户端如何与服务交互。
- 创建遵循客户端接口的适配器类。 所有方法暂时都为空。
- 在适配器类中添加一个成员变量用于保存对于服务对象的引用。 通常情况下会通过构造函数对该成员变量进行初始化， 但有时在调用其方法时将该变量传递给适配器会更方便。
- 依次实现适配器类客户端接口的所有方法。 适配器会将实际工作委派给服务对象， 自身只负责接口或数据格式的转换。
- 客户端必须通过客户端接口使用适配器。 这样一来， 你就可以在不影响客户端代码的情况下修改或扩展适配器。

## 优缺点

**优点**：

- 单一职责原则你可以将接口或数据转换代码从程序主要业务逻辑中分离。
- 开闭原则。 只要客户端代码通过客户端接口与适配器进行交互， 你就能在不修改现有客户端代码的情况下在程序中添加新类型的适配器。

**缺点**：

- 代码整体复杂度增加， 因为你需要新增一系列接口和类。 有时直接更改服务类使其与其他代码兼容会更简单。

> 核心思想: 将一个类的接口转换成客户端期望的另一个接口，使得原本由于接口不兼容而无法一起工作的类可以协同工作。
